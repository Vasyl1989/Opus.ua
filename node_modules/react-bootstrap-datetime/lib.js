// Generated by CoffeeScript 1.9.2
var Button, ButtonGroup, ButtonToolbar, DatePicker, DateTime, DropdownButton, Glyphicon, Input, MenuItem, MonthPicker, PickerMixin, PropTypes, Table, TimePicker, YearPicker, createClass, createElement, createFactory, defaultFormat, formatRegex, moment, ref, ref1, ref2, table, tbody, td, th, thead, tr;

ref = require("react"), createClass = ref.createClass, createElement = ref.createElement, createFactory = ref.createFactory, (ref1 = ref.DOM, table = ref1.table, thead = ref1.thead, tbody = ref1.tbody, th = ref1.th, tr = ref1.tr, td = ref1.td), PropTypes = ref.PropTypes;

ref2 = require("react-bootstrap"), Input = ref2.Input, ButtonToolbar = ref2.ButtonToolbar, ButtonGroup = ref2.ButtonGroup, Button = ref2.Button, DropdownButton = ref2.DropdownButton, MenuItem = ref2.MenuItem, Table = ref2.Table, Glyphicon = ref2.Glyphicon;

moment = require("moment");

defaultFormat = moment.defaultFormat;

formatRegex = /([QeEAaXx]|M{1,4}o?|D{1,4}o?|d{1,4}o?|w{1,2}o?|W{1,2}o?|Y{2,4}|g{2,4}|G{2,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,2}|Z{1,2})/;

PickerMixin = {
  propTypes: function() {
    return {
      format: PropTypes.string,
      value: PropTypes.string,
      defaultValue: PropTypes.string,
      locale: PropTypes.string,
      minValue: PropTypes.string,
      maxValue: PropTypes.string
    };
  },
  getDefaultProps: function() {
    return {
      locale: moment.locale(),
      format: defaultFormat,
      defaultValue: (moment()).format(defaultFormat),
      minValue: false,
      maxValue: false
    };
  },
  getInitialState: function() {
    var defaultValue, locale, ref3, value;
    ref3 = this.props, value = ref3.value, defaultValue = ref3.defaultValue, locale = ref3.locale;
    if (locale != null) {
      if (typeof this.setLocale === "function") {
        this.setLocale(locale);
      }
    }
    if (value == null) {
      value = defaultValue;
    }
    return {
      value: value
    };
  },
  applyLimits: function(value, minValue, maxValue) {
    var format;
    if (minValue == null) {
      minValue = this.props.minValue;
    }
    if (maxValue == null) {
      maxValue = this.props.maxValue;
    }
    if (value == null) {
      value = this.state.value;
    }
    if (minValue || maxValue) {
      format = this.props.format;
      value = moment(value, format);
      if (minValue && value.isBefore((minValue = moment(minValue, format)))) {
        value = minValue;
      }
      if (maxValue && value.isAfter((maxValue = moment(maxValue, format)))) {
        value = maxValue;
      }
      return value.format(format);
    } else {
      return value;
    }
  },
  supUnits: {
    year: null,
    month: "year",
    date: "month",
    hour: "date",
    minute: "hour",
    second: "minute"
  },
  isSameBase: function(units, value1, value2) {
    var supUnits;
    supUnits = this.supUnits[units];
    return (supUnits == null) || (value1.get(supUnits)) === (value2.get(supUnits)) && this.isSameBase(supUnits, value1, value2);
  },
  getLimits: function(units) {
    var datetime, format, maxValue, minValue, ref3;
    ref3 = this.props, format = ref3.format, minValue = ref3.minValue, maxValue = ref3.maxValue;
    datetime = this.getMoment();
    return [minValue && this.isSameBase(units, datetime, minValue = moment(minValue, format)) ? minValue.get(units) : void 0, maxValue && this.isSameBase(units, datetime, maxValue = moment(maxValue, format)) ? maxValue.get(units) : void 0];
  },
  componentWillReceiveProps: function(arg) {
    var locale, maxValue, minValue, value;
    value = arg.value, locale = arg.locale, minValue = arg.minValue, maxValue = arg.maxValue;
    value = this.applyLimits(value, minValue, maxValue);
    this.setValue(value, false);
    if ((locale != null) && locale !== this.props.locale) {
      return typeof this.setLocale === "function" ? this.setLocale(locale) : void 0;
    }
  },
  setValue: function(value, update) {
    var onChange;
    if (update == null) {
      update = true;
    }
    onChange = this.props.onChange;
    if (value != null) {
      if (value !== this.state.value) {
        return this.setState({
          value: value
        }, (update ? onChange : void 0));
      } else {
        if (update && onChange) {
          return onChange();
        }
      }
    }
  },
  modifyValue: function(fn) {
    var datetime;
    datetime = this.getMoment();
    fn.call(datetime);
    return this.setValue(this.applyLimits(datetime.format(this.props.format)));
  },
  parseFormat: function(format) {
    return format.split(formatRegex);
  },
  getMoment: function() {
    var datetime, format, locale, ref3, value;
    ref3 = this.props, format = ref3.format, locale = ref3.locale;
    value = this.state.value;
    datetime = moment(value, format);
    if (locale) {
      datetime.locale(locale);
    }
    return datetime;
  },
  getValue: function() {
    return this.state.value;
  },
  wheelValue: function(e, p, n) {
    var delta;
    if (n == null) {
      n = 1;
    }
    e.preventDefault();
    delta = e.deltaY || e.deltaX;
    delta /= -Math.abs(delta);
    delta *= n;
    return this.modifyValue(function() {
      return this.add(delta, p);
    });
  }
};

YearPicker = createClass({
  mixins: [PickerMixin],
  getDefaultProps: function() {
    return {
      yearsRange: [-12, 12]
    };
  },
  getInitialState: function() {
    return {
      yearsOffset: 0
    };
  },
  pageYears: function(page) {
    var yearsOffset, yearsRange;
    yearsRange = this.props.yearsRange;
    yearsOffset = this.state.yearsOffset;
    yearsOffset += page * (yearsRange[1] - yearsRange[0]);
    return this.setState({
      yearsOffset: yearsOffset
    });
  },
  prevYears: function() {
    return this.pageYears(-1);
  },
  nextYears: function() {
    return this.pageYears(1);
  },
  pickYear: function(year) {
    return (function(_this) {
      return function() {
        return _this.modifyValue(function() {
          return this.year(year);
        });
      };
    })(this);
  },
  render: function() {
    var activeYear, baseYear, col, cols, datetime, firstYear, lastYear, maxYear, minYear, ref3, row, rows, year, years, yearsOffset, yearsRange;
    datetime = this.getMoment();
    yearsRange = this.props.yearsRange;
    yearsOffset = this.state.yearsOffset;
    ref3 = this.getLimits("year"), minYear = ref3[0], maxYear = ref3[1];
    activeYear = datetime.year();
    baseYear = activeYear + yearsOffset;
    firstYear = yearsRange[0] + baseYear;
    lastYear = yearsRange[1] + baseYear;
    years = yearsRange[1] - yearsRange[0] + 1;
    cols = Math.ceil(Math.sqrt(years));
    rows = Math.ceil(years / cols);
    return table(null, thead(null, tr(null, th({
      colSpan: cols - 1
    }, createElement(Button, {
      bsStyle: "link",
      onClick: this.prevYears
    }, createElement(Glyphicon, {
      glyph: "chevron-left"
    }))), th({
      className: "pull-right"
    }, createElement(Button, {
      bsStyle: "link",
      onClick: this.nextYears
    }, createElement(Glyphicon, {
      glyph: "chevron-right"
    }))))), tbody(null, (function() {
      var i, ref4, results;
      results = [];
      for (row = i = 0, ref4 = rows; 0 <= ref4 ? i < ref4 : i > ref4; row = 0 <= ref4 ? ++i : --i) {
        results.push(tr({
          key: row
        }, (function() {
          var j, ref5, results1;
          results1 = [];
          for (col = j = 0, ref5 = cols; 0 <= ref5 ? j < ref5 : j > ref5; col = 0 <= ref5 ? ++j : --j) {
            year = firstYear + row * cols + col;
            results1.push(td({
              key: col
            }, year <= lastYear ? createElement(Button, {
              bsStyle: year === activeYear ? "primary" : "link",
              onClick: this.pickYear(year),
              disabled: (minYear != null) && year < minYear || (maxYear != null) && year > maxYear
            }, year) : void 0));
          }
          return results1;
        }).call(this)));
      }
      return results;
    }).call(this)));
  }
});

MonthPicker = createClass({
  mixins: [PickerMixin],
  pickMon: function(mon) {
    return (function(_this) {
      return function() {
        return _this.modifyValue(function() {
          return this.month(mon);
        });
      };
    })(this);
  },
  setLocale: function(locale) {
    var datetime, month;
    datetime = moment();
    datetime.locale(locale);
    return this.monthName = (function() {
      var i, results;
      results = [];
      for (month = i = 0; i < 12; month = ++i) {
        results.push((datetime.month(month)).format("MMMM"));
      }
      return results;
    })();
  },
  render: function() {
    var activeMonth, col, cols, datetime, maxMonth, minMonth, month, ref3, row, rows;
    datetime = this.getMoment();
    activeMonth = datetime.month();
    ref3 = this.getLimits("month"), minMonth = ref3[0], maxMonth = ref3[1];
    cols = 3;
    rows = 4;
    return table(null, tbody(null, (function() {
      var i, ref4, results;
      results = [];
      for (row = i = 0, ref4 = rows; 0 <= ref4 ? i < ref4 : i > ref4; row = 0 <= ref4 ? ++i : --i) {
        results.push(tr({
          key: row
        }, (function() {
          var j, ref5, results1;
          results1 = [];
          for (col = j = 0, ref5 = cols; 0 <= ref5 ? j < ref5 : j > ref5; col = 0 <= ref5 ? ++j : --j) {
            month = row * cols + col;
            results1.push(td({
              key: col
            }, createElement(Button, {
              bsStyle: month === activeMonth ? "primary" : "link",
              onClick: this.pickMon(month),
              disabled: (minMonth != null) && month < minMonth || (maxMonth != null) && month > maxMonth
            }, this.monthName[month])));
          }
          return results1;
        }).call(this)));
      }
      return results;
    }).call(this)));
  }
});

DatePicker = createClass({
  mixins: [PickerMixin],
  prevMon: function() {
    return this.modifyValue(function() {
      return this.subtract(1, "M");
    });
  },
  nextMon: function() {
    return this.modifyValue(function() {
      return this.add(1, "M");
    });
  },
  wheelMon: function(e) {
    return this.wheelValue(e, "M", -1);
  },
  wheelYear: function(e) {
    return this.wheelValue(e, "Y", -1);
  },
  pickDate: function(date) {
    return (function(_this) {
      return function() {
        return _this.modifyValue(function() {
          return this.date(date);
        });
      };
    })(this);
  },
  setLocale: function(locale) {
    var datetime, weekday;
    datetime = moment();
    datetime.locale(locale);
    return this.weekdayName = (function() {
      var i, results;
      results = [];
      for (weekday = i = 0; i < 7; weekday = ++i) {
        results.push((datetime.weekday(weekday)).format("ddd"));
      }
      return results;
    })();
  },
  render: function() {
    var activeDate, date, datetime, day, firstDay, firstWeek, lastDay, lastWeek, lastWeekIsFirst, maxDate, minDate, monthDays, onClickMonth, onClickYear, ref3, ref4, week;
    ref3 = this.props, onClickYear = ref3.onClickYear, onClickMonth = ref3.onClickMonth;
    datetime = this.getMoment();
    activeDate = datetime.date();
    monthDays = datetime.daysInMonth();
    firstWeek = ((datetime.clone()).date(1)).week();
    lastWeek = ((datetime.clone()).date(monthDays)).week();
    lastWeekIsFirst = false;
    if (lastWeek < firstWeek) {
      lastWeekIsFirst = true;
      lastDay = monthDays;
      while (lastWeek < firstWeek) {
        lastWeek = ((datetime.clone()).date(lastDay)).week();
        lastDay -= 1;
      }
      lastWeek += 1;
    }
    firstDay = ((datetime.clone()).date(1)).weekday();
    lastDay = ((datetime.clone()).date(monthDays)).weekday();
    ref4 = this.getLimits("date"), minDate = ref4[0], maxDate = ref4[1];
    return table({
      key: "days"
    }, thead(null, tr(null, th(null, createElement(Button, {
      bsStyle: "link",
      onClick: this.prevMon
    }, createElement(Glyphicon, {
      glyph: "chevron-left"
    }))), th({
      colSpan: 3,
      style: {
        textAlign: "center"
      }
    }, createElement(Button, {
      bsStyle: "link",
      onWheel: this.wheelYear,
      onClick: onClickYear
    }, datetime.format("YYYY"))), th({
      colSpan: 3,
      style: {
        textAlign: "center"
      }
    }, createElement(Button, {
      bsStyle: "link",
      onWheel: this.wheelMon,
      onClick: onClickMonth
    }, datetime.format("MMMM"))), th(null, createElement(Button, {
      bsStyle: "link",
      onClick: this.nextMon
    }, createElement(Glyphicon, {
      glyph: "chevron-right"
    }))))), tbody(null, tr(null, th(null), (function() {
      var i, results;
      results = [];
      for (day = i = 0; i < 7; day = ++i) {
        results.push(th({
          key: day,
          style: {
            textAlign: "center"
          }
        }, this.weekdayName[day]));
      }
      return results;
    }).call(this)), (function() {
      var i, ref5, ref6, results;
      results = [];
      for (week = i = ref5 = firstWeek, ref6 = lastWeek; ref5 <= ref6 ? i <= ref6 : i >= ref6; week = ref5 <= ref6 ? ++i : --i) {
        results.push(tr({
          key: week
        }, th(null, week), (function() {
          var j, results1;
          results1 = [];
          for (day = j = 0; j < 7; day = ++j) {
            date = (week - firstWeek) * 7 + day - firstDay + 1;
            results1.push(td({
              key: day
            }, (week !== firstWeek || day >= firstDay) && (week !== lastWeek || day <= lastDay) ? createElement(Button, {
              bsStyle: date === activeDate ? "primary" : "link",
              onClick: this.pickDate(date),
              disabled: (minDate != null) && date < minDate || (maxDate != null) && date > maxDate
            }, date) : void 0));
          }
          return results1;
        }).call(this)));
      }
      return results;
    }).call(this)));
  }
});

TimePicker = createClass({
  mixins: [PickerMixin],
  getDefaultProps: function() {
    return {
      display: "HH:mm:ss"
    };
  },
  prevHour: function() {
    return this.modifyValue(function() {
      return this.subtract(1, "h");
    });
  },
  nextHour: function() {
    return this.modifyValue(function() {
      return this.add(1, "h");
    });
  },
  wheelHour: function(e) {
    return this.wheelValue(e, "h");
  },
  prevMin: function() {
    return this.modifyValue(function() {
      return this.subtract(1, "m");
    });
  },
  nextMin: function() {
    return this.modifyValue(function() {
      return this.add(1, "m");
    });
  },
  wheelMin: function(e) {
    return this.wheelValue(e, "m");
  },
  prevSec: function() {
    return this.modifyValue(function() {
      return this.subtract(1, "s");
    });
  },
  nextSec: function() {
    return this.modifyValue(function() {
      return this.add(1, "s");
    });
  },
  wheelSec: function(e) {
    return this.wheelValue(e, "s");
  },
  toggleAPM: function() {
    return this.modifyValue(function() {
      if (12 >= this.hour()) {
        return this.add(12, "h");
      } else {
        return this.subtract(12, "h");
      }
    });
  },
  render: function() {
    var datetime, hour, index, maxHour, maxMin, maxSec, min, minHour, minMin, minSec, ref3, ref4, ref5, sec, token, tokens;
    datetime = this.getMoment();
    tokens = this.parseFormat(this.props.display);
    ref3 = this.getLimits("hour"), minHour = ref3[0], maxHour = ref3[1];
    ref4 = this.getLimits("minute"), minMin = ref4[0], maxMin = ref4[1];
    ref5 = this.getLimits("second"), minSec = ref5[0], maxSec = ref5[1];
    hour = datetime.hour();
    min = datetime.minute();
    sec = datetime.second();
    return table(null, tbody(null, tr(null, (function() {
      var i, len, results;
      results = [];
      for (index = i = 0, len = tokens.length; i < len; index = ++i) {
        token = tokens[index];
        results.push(td({
          key: index
        }, (function() {
          switch (false) {
            case !/^[Hh]/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.nextHour,
                disabled: (maxHour != null) && hour >= maxHour
              }, createElement(Glyphicon, {
                glyph: "chevron-up"
              }));
            case !/^m/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.nextMin,
                disabled: (maxMin != null) && min >= maxMin
              }, createElement(Glyphicon, {
                glyph: "chevron-up"
              }));
            case !/^s/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.nextSec,
                disabled: (maxSec != null) && sec >= maxSec
              }, createElement(Glyphicon, {
                glyph: "chevron-up"
              }));
          }
        }).call(this)));
      }
      return results;
    }).call(this)), tr(null, (function() {
      var i, len, results;
      results = [];
      for (index = i = 0, len = tokens.length; i < len; index = ++i) {
        token = tokens[index];
        results.push(td({
          key: index
        }, (function() {
          switch (false) {
            case !/^[Hh]/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onWheel: this.wheelHour
              }, datetime.format(token));
            case !/^m/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onWheel: this.wheelMin
              }, datetime.format(token));
            case !/^s/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onWheel: this.wheelSec
              }, datetime.format(token));
            case !/^[aA]/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.toggleAPM
              }, datetime.format(token));
            default:
              return token;
          }
        }).call(this)));
      }
      return results;
    }).call(this)), tr(null, (function() {
      var i, len, results;
      results = [];
      for (index = i = 0, len = tokens.length; i < len; index = ++i) {
        token = tokens[index];
        results.push(td({
          key: index
        }, (function() {
          switch (false) {
            case !/^[Hh]/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.prevHour,
                disabled: (minHour != null) && hour <= minHour
              }, createElement(Glyphicon, {
                glyph: "chevron-down"
              }));
            case !/^m/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.prevMin,
                disabled: (minMin != null) && min <= minMin
              }, createElement(Glyphicon, {
                glyph: "chevron-down"
              }));
            case !/^s/.test(token):
              return createElement(Button, {
                bsStyle: "link",
                onClick: this.prevSec,
                disabled: (minSec != null) && sec <= minSec
              }, createElement(Glyphicon, {
                glyph: "chevron-down"
              }));
          }
        }).call(this)));
      }
      return results;
    }).call(this))));
  }
});

DateTime = createClass({
  mixins: [PickerMixin],
  propTypes: function() {
    return {
      label: PropTypes.string,
      help: PropTypes.string
    };
  },
  getDefaultProps: function() {
    return {
      datePart: "YYYY-MM-DD",
      timePart: "HH:mm:ss",
      dateGlyph: "calendar",
      timeGlyph: "time"
    };
  },
  getInitialState: function() {
    return {
      dateView: "days"
    };
  },
  viewDays: function() {
    return this.setState({
      dateView: "days"
    });
  },
  viewYears: function() {
    return this.setState({
      dateView: "years"
    });
  },
  viewMonths: function() {
    return this.setState({
      dateView: "months"
    });
  },
  updateValue: function(field) {
    return this.setValue(this.refs[field].getValue());
  },
  handleYear: function() {
    this.updateValue("year");
    return this.viewDays();
  },
  handleMonth: function() {
    this.updateValue("month");
    return this.viewDays();
  },
  handleDay: function() {
    return this.updateValue("day");
  },
  handleTime: function() {
    return this.updateValue("time");
  },
  render: function() {
    var addonAfter, addonBefore, bsStyle, dateGlyph, datePart, dateView, datetime, dropup, format, help, label, locale, maxValue, minValue, ref3, ref4, timeGlyph, timePart, value;
    ref3 = this.props, label = ref3.label, help = ref3.help, addonBefore = ref3.addonBefore, addonAfter = ref3.addonAfter, format = ref3.format, datePart = ref3.datePart, timePart = ref3.timePart, dateGlyph = ref3.dateGlyph, timeGlyph = ref3.timeGlyph, dropup = ref3.dropup, bsStyle = ref3.bsStyle, locale = ref3.locale, minValue = ref3.minValue, maxValue = ref3.maxValue;
    ref4 = this.state, value = ref4.value, dateView = ref4.dateView;
    datetime = this.getMoment();
    return createElement(Input, {
      label: label,
      help: help,
      addonBefore: addonBefore,
      addonAfter: addonAfter
    }, createElement(ButtonToolbar, null, createElement(ButtonGroup, null, datePart ? createElement(DropdownButton, {
      noCaret: true,
      dropup: dropup,
      bsStyle: bsStyle,
      title: [
        datetime.format(datePart), dateGlyph ? " " : void 0, dateGlyph ? createElement(Glyphicon, {
          key: "glyph",
          glyph: dateGlyph
        }) : void 0
      ]
    }, createElement(MenuItem, {
      style: {
        display: "days" === dateView ? "block" : "none"
      },
      header: true
    }, createElement(DatePicker, {
      ref: "day",
      locale: locale,
      format: format,
      onChange: this.handleDay,
      onClickYear: this.viewYears,
      onClickMonth: this.viewMonths,
      value: value,
      minValue: minValue,
      maxValue: maxValue
    })), createElement(MenuItem, {
      style: {
        display: "months" === dateView ? "block" : "none"
      },
      header: true
    }, createElement(MonthPicker, {
      ref: "month",
      locale: locale,
      format: format,
      onChange: this.handleMonth,
      value: value,
      minValue: minValue,
      maxValue: maxValue
    })), createElement(MenuItem, {
      style: {
        display: "years" === dateView ? "block" : "none"
      },
      header: true
    }, createElement(YearPicker, {
      ref: "year",
      locale: locale,
      format: format,
      onChange: this.handleYear,
      value: value,
      minValue: minValue,
      maxValue: maxValue
    }))) : void 0, timePart ? createElement(DropdownButton, {
      noCaret: true,
      dropup: dropup,
      bsStyle: bsStyle,
      title: [
        datetime.format(timePart), timeGlyph ? " " : void 0, timeGlyph ? createElement(Glyphicon, {
          key: "glyph",
          glyph: timeGlyph
        }) : void 0
      ]
    }, createElement(MenuItem, {
      header: true
    }, createElement(TimePicker, {
      ref: "time",
      locale: locale,
      format: format,
      display: timePart,
      onChange: this.handleTime,
      value: value,
      minValue: minValue,
      maxValue: maxValue
    }))) : void 0)));
  }
});

module.exports = {
  PickerMixin: PickerMixin,
  YearPicker: YearPicker,
  MonthPicker: MonthPicker,
  DatePicker: DatePicker,
  TimePicker: TimePicker,
  DateTime: DateTime
};
